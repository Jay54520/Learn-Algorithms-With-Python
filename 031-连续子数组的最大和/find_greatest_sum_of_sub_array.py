# -*- coding:utf-8 -*-
class Solution:
    def FindGreatestSumOfSubArray(self, array):
        """
        返回连续子数组的最大和。
        比如对于 [6,-3,-2,7,-15,1,2,2]，返回 [6, -3, -2, 7] 的和 —— 8.

        数组中可能含有负数，所以要往后看是否有正数能抵消这个负数的效果。
        连续子数组：
            * 起点可以是数组中的任何位置
            * 起点到终点必须是向右连续的
            * 子数组数量大于等于 1 个

        算法1：

        依次找出所有子数组，求它们的和并与最大和比较。

        复杂度分析：

        时间复杂度：子数组数量为 1 有 n 种情况，数量为 2 有 n - 1 ...  1 种，
        所以为 n + (n - 1) + ... + 1 = O(n^2)；依次对这些数组求和，总计也是 O(n^2)，所以为 O(n^2)
        空间复杂度：O(1)，只需要储存最大和

        算法2：

        条件：

        * 负数会使和变小，正数和 0 不会使和变小。
        * 由于子数组是连续的，所以可以将起点到当前的数字的和视作一个数字

        算法：

        如果是负数，由于它会使和变小，所以跳过；反之，可以继续。
        但如果数组中都是负数，那么最大和就是单个负数，所以在每次操作后我们比较当前和与当前最大和，然后根据情况替换最大和。
        这样就包含了所有情况，所以可证。

        * 初始化最大和为第一个数
        * 初始化当前和为 None，原因见下方
        * 然后循环数组并累加到当前和中，如果当前和大于最大和，将最大和设置为当前和：
            * 如果当前和小于 0，然后清空当前和，然后跳过
                * 如何清空当前和？如果将它设置为 0，当输入数组都是负数数，就会错误；
                * 将其设置为 None
            * 否则，继续
        * 返回最大和，结束

        复杂度分析：

        时间复杂度：O(n)，遍历一次数组，在每次循环中只是常书级操作，所以为 O(n)
        空间复杂度：O(1)，只需要储存最大和

        边界条件：

        * 数组为空，抛出异常。如果返回 0，那么你不知道是数组不为空时的 0 还是数组为空时的 0
        * 数组都是负数，由于每次都会比较并丢弃，所以成立
        * 数组都是正数，由于不会丢弃，所以是所有正数的和，成立
        * 数组有正数有负数
            * 当前和存在负数
            * 当前和不存在负数
            * 子数组从第一个位置开始
            * 子数组从第二个位置开始

        以动态规划证明：

        假定 f(i) 是以第 i 个数字结尾的子树组的最大和，那么我们需要求的是 max(f(i))，
        0 <= i < n（这里的以第 i 个数字结尾的定义很巧妙，能用函数表示定义。我之前想的是以第 i 个数字
        开头的子数组，这样就不能用函数表示出来）。

        f(i):

        1.  array[i], i = 0 或 f(i - 1) < 0
        2. f(i - 1) + array[i], i != 0 且 f(i - 1) >= 0

        对于 1，因为 f(i - 1) < 0，所以加上它会使 f(i) 变小，所以我们不加它；
        对于 2，由于加上 f(i - 1) 会使 f(i) 变大，所以我们加上它

        用强归纳法证明：

        假设小于 n 的 f(i) 都成立，如果能根据这个条件推导出 f(n) 成立，那么 f(i) 成立。

        * 如果 f(n - 1) < 0，因为 f(n - 1) 为之前数组的最大值，
        而负数会使和变小，所以为 array[n]，符合定义；
        * 否则，f(n - 1) >= 0，不会使和变小，所以最大值为 f(n - 1) + array[n]

        上述两种情况与 f(i) 的定义相同，所以 f(i) 成立。

        """
        if not array:
            raise ValueError('输入的数组不能为空')

        greatest_sum = array[0]
        current_sum = None

        for num in array:
            if current_sum is None:
                current_sum = num
            else:
                current_sum += num

            if current_sum > greatest_sum:
                greatest_sum = current_sum

            if current_sum < 0:
                current_sum = None
        return greatest_sum