# -*- coding:utf-8 -*-
import math


class Solution:
    def NumberOf1Between1AndN_Solution(self, n):
        """
        未解决，需要帮助。

        求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。

        比如 1-13中包含1的数字有 1、10、11、12、13，所以 1 出现的次数为：
        1 + 1 + 2 + 1 + 1 = 6

        算法3：

        https://www.nowcoder.com/questionTerminal/bd7f978302044eee894445e244c7eee6 藍裙子的百合魂

        设N = abcde ,其中abcde分别为十进制中各位上的数字，则含有 1 的形式为 [][]1[][]。
        如果要计算百位上1出现的次数，它要受到3方面的影响：百位上的数字，百位以下（低位）的数字，百位以上（高位）的数字。
        ① 如果百位上数字为0，百位上可能出现1的次数由更高位决定。比如：12013，
        个为和十位都可以为 0~9，所以一共有 10 * 10 = 100 种情况。
        万位和千位，从 00~11（因为百位上的数字为 0 小于 1，所以最大为 11） 有 12 种情况，所以一共有 12 * 100 = 1200 种情况。

        ② 如果百位上数字为1，百位上可能出现1的次数不仅受更高位影响还受低位影响。比如：12113，
        在 ① 的 1200 基础上，加上 12100~12113 这 14（低位数字 13 + 1） 种情况。

        ③ 如果百位上数字大于1（2~9），则百位上出现1的情况仅由更高位决定，比如12213，
        个为和十位都可以为 0~9，所以一共有 10 * 10 = 100 种情况。
        万位和千位，从 00~12，有 13 种情况，所以一共有 13 * 100 = 1300 种。

        复杂度分析：
        时间复杂度：O(logn)，只需要循环 logn 次且每次循环中都是常数级运算。
        空间复杂度：O(1)

        边界情况：

        * n <= 0，返回 0
        """
        count = 0
        i = 1
        while n // i != 0:
            current = (n // i) % 10
            before = (n // i) // 10
            after = n - n // i * i
            if current == 0:
                count += before * i
            elif current == 1:
                count += before * i + after + 1
            else:
                count += (before + 1) * i
            i *= 10
        return count