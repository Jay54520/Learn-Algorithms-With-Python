# -*- coding:utf-8 -*-
class Solution:
    def LastRemaining_Solution(self, n, m):
        """
        0 ~ (n - 1) 这 n 个数字排成一个圆圈，从数字 0 开始每次从这个圆圈
        里删除第 m 个数字。求圆圈里最后剩下的数字。

        比如 0->1->2->3->4
            |-----------|
        当 m = 3 时，删除的前 4 个数字是 2、0、4、1。

        算法1：
        使用数组模拟环，数组的最后一个索引之后就是第一个索引。通过对长度取余即可实现。
        如果数组中含有多于 1 个元素，则一直删除当前索引后的第 m 个，删除之后当前的索引
        就指向了之前的后一个元素。
        跳出循环后，数组中只剩下一个元素，即为结果。

        复杂度分析：
        时间复杂度：O(n^2)。pop() 操作：n + n - 1 + ... + 1 = O(n^2)
        空间复杂度：O(n)。用于储存的数组。
        """
        # AC 的要求
        if m == 0 and n == 0:
            return -1

        nums = list(range(n))
        i = 0
        while len(nums) > 1:
            i = (i + m - 1) % len(nums)
            nums.pop(i)
        return nums[0]
